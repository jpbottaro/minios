El orden en que escribí el código fue primero el FS, luego el kernel y por
último las utilidades. Sin embargo para hacerlo más consistente se presentará
primero el kernel, que pega todos los componentes y facilita la explicación del
FS y las utilidades.

El kernel está basado en el utilizado en la cursada de Organización del
Computador 2, 2do cuatrimestre del 2010. En este sistema armamos las
estructuras necesarias para botear un sistema en modo protegido con paginación.
Esto incluye un bootloader que carge la imagen, el manejo del A20, y llenado de
GDT/IDT/TSS etc. Esto permitía manejo de interrupciones y dio lugar a un simple
scheduler que daba una forma primitiva de multiprogramación.

Si bien partí de esta base de código, muchos de los componentes fueron
modificados o reescritos totalmente. Los cambios más importantes fueron en el
scheduler (conjunto con el manjeo de tss), el manejo de procesos, el mmu o
manejo de la memoria y el manejo del teclado/pantalla.

Antes de comenzar a hablar sobre cada componente en detalle, voy a dar algunas
características generales del kernel. Este núcleo utiliza la idea de "Lower
Half Kernel", o kernel en la parte baja de la memoria. Esto significa que la
imagen del kernel se copia y mapea virtualmente en los primeros 4mb de la
memoria. En un principio pensé utilizar la idea de "Higher Half Kernel" en
donde el mapeo se hace al final de la memoria (en general al rededor de los
3gb), que es la que se utiliza en las kernels modernas (linux, windows, bsd,
etc), haciendo la carga de los programas más simple y por sobretodo
manteniendome en el standar. Sin embargo debido a no tener control sobre el
bootloader, y no siendo este compatible con multiboot, me fue imposible
controlar la carga de la imagen y por ende abandoné la idea.

Las implicaciónes de esta decisión fueron que al compilar las aplicaciónes de
usuario, estas deben empezar con el offset de 4mb, o 0x400000 en hexa, para que
tengan sentido todos los punteros. Para ver más sobre esta explicación,
dirigirse a la sección "Manejo de Procesos" y "Utilidades" al final del
informe.

Desde un primer momento me propuse implementar una interfaz con el usuario del
tipo POSIX, es decir utilizar al igual que linux/bsd la interrupción 0x80 para
manejar llamadas al sistema. Respeté todos las signaturas de las llamadas POSIX
(exit/open/close/write/etc.), sus números de interrupción, logrando de esta
manera tener un sistema "compatible" con linux. Si bien obviamente esta
compatibilidad es muy reducida, en la sección de utilidades se mostrará como
todas las aplicaciónes programadas para esta kernel funcionan sin ninguna
modificación en un sistema linux.

Otro punto importante es el uso de sys/queue.h. Este header extraido de minix
(que a su vez fue extraido de NetBSD) contienen una implementación estandar
varios tipos de listas (comunes, doble enlazadas, circulares, etc). Esto es
utilizado en varias partes, incluyendo el scheduler, el manejo de memoria, y en
el fs. Para entender más sobre esto dirigirse a sus respectivas páginas en el
manual ("man queue").

\subsection{Manejo de Procesos}

El manejo de procesos en el kernel se encarga de mantener información sobre
todos los procesos actualmente en el sistema, información relevante para el
scheduler/tty/fs etc. La implementación del mismo se encuentra en los archivos
kernel/sched.c y kernel/sched.h. Es importante notar que en el código, no hay
distinción entre manejo de procesos y scheduler, ambos se encuentran en el
mismo archivo.

Cada proceso en el sistema ocupa una pocisión en el arreglo "ps", de tipo
"struct process\_state\_s" definido en include/minikernel/sched.h. Esta
estructura contiene información como el pid/uid/gid del proceso, un puntero al
padre, la información del fs (directorio actual, descriptores de archivo
abiertos, etc), una serie de entradas de manejo de listas, y una lista de
páginas utilizadas. Toda esta información, más el estado del proceso guardado
en su respectivo TSS, define el estado de cualquier proceso en el sistema.

Aquí son definidas los handlers de todas las llamadas al sistema que manejan
procesos. Estas incluyen exit()/waitpid()/getpid() entre otras.

La llamada exit() se encarga de liberar todas las páginas pedidas por el
proceso, removerlo de la lista de procesos listos del scheduler, despertar al
padre si este estaba dormido esperandolo (con waitpid()), y programar el
siguiente proceso a ser ejecutado.

waitpid() recibe un pid de un proceso hijo, y bloquea al proceso que ejecuto la
llamada hasta que no termine el proceso hijo. Es utilizado por ejemplo en la
consola para esperar a que un comando enviado termine de ejecutarse. Logra esto
removiendo al proceso de la lista del scheduler, y apuntando en su estructura
al proceso que espera que termine. Lo despierta exit().

getpid() simplemente devuelve el pid de la estructura "ps".

Obvié intencionalmente a las dos llamadas más importantes, fork() y execve().
En un principio comencé a utilizar este modelo para crear nuevos procesos, pero
resultó tener varias complicaciónes que no esperaba (en especial cuando se
realiza el fork() y no se sigue con el execv(), copiar el estado de un proceso
no era tan simple), por lo que decidí unir ambas llamadas y crear una nueva,
denominada newprocess(). Esta recibe los mismos parametros que execv(), el path
del proceso y el arreglo de argumentos argv, y realiza todo sola, crea el
proceso y lo prepara para ser ejecutado. Esta es la única razón que hace que
una aplicación ("cash", la consola) no compile directamente para un sistema
linux, es necesario reemplazar la llamada a newprocess() por un fork() y un
execv() y se logra la compatibilidad.

newprocess() es la llamada más complicada del manejo de procesos, y consiste en
los siguientes pasos:

- se consigue una entrada libre en el arreglo "ps"

- se busca en el sistema de archivos el inodo correspondiente al path pedido
por el usuario

- se inicializa la estructura process\_state\_s con datos como pid/uid/gid,
parent, se inicializan los file descriptors del proceso y la lista de páginas
utilizadas (todavía ninguna).

- se arma el nuevo directorio de páginas o PDT del proceso. Esto implica armar
un PDT con los primeros 4mb con identity mapping (para el kernel). Además se
arman todas las páginas de código/stack/argumentos necesarios, ver más abajo
para la explicación.

- se llena la entrada correspondiente en la tss para el proceso con esta nueva
PDT

- se agrega el proceso a la lista ready del scheduler

Esto concluye la carga de un programa y este se encuentra listo para ejecución.

El armado del PDT tiene un par de etapas, y es necesario saber algunas reglas
que decidí para construirlo. Primero en principal, todo el código se carga a
partir de la dirección 0x400000, es decir se copia el codigo en una serie de
páginas que pueden estar fisicamente en cualquier lado, pero que deben mapearse
en orden a partir de esta dirección. Esto evita tener que responder Page Faults
(todo se copia de antemano). Luego la stack esta mapeada en la última posición
posible, es decir la 0xFFFFF000, y le sigue la stack del kernel (necesaria para
atender interrupciones) en 0xFFFFE000. De nuevo, estas páginas son pedidas al
MMU y pueden estar en cualquier lado, pero la PDT debe encargarse de mapearlas
en estas direcciones.

Por último se agregó soporte para argumentos, que en C corresponden a los
parametros argc y argv del main(). No sabía muy bien como era que se les
entregaban argumentos a un programa de C por lo que recurrí a una
herramienta que resulto indispensable en el proyecto, objdump. Decompilando un
ejecutable común de C pude ver que main() espera estos argumentos como cualquier
otra función, en la pila antes de la dirección de retorno. Esto implica que al
crear un proceso, debía armar su pila de manera que main() recibiera bien estos
parametros.

La otra complicación que surgió fue que, al crear un proceso, uno provee el
argv ya armado. Pero este arreglo es de punteros a cadenas y las cadenas mismas
son datos del proceso que realiza la system call, pero el nuevo proceso no
comparte el espacio de datos del viejo, por lo que no puede accederlas. La
solución fue crear una nueva página en newproces() que mapee en 0xFFFFD000, y
copiar todas las strings de los argumentos ahí. Luego armar en esta misma
página un nuevo argv con los punteros a estas nuevas strings. Por último puse
el puntero a este argv en el stack del proceso, logrando así la compatibilidad
con C.

\subsection{Scheduler y TSS}

El scheduler también se encuentra en los archivos kernel/sched.c y
kernel/sched.h. Este comprende las funciones
init\_scheduler()/schedule()/block\_process()/unblock\_process().

La función init\_scheduler() debe ser ejecutada antes de que se activen las
iterrupciones en el sistema. Esta se encarga de inicializar las listas
necesarias para la programación de tareas (ready/waiting), inicializa los tss,
y crea la tarea idle, que será ejecutada siempre que la lista ready este vacía.

schedule() es la función más importante, es llamada siempre que ocurre la
interrupción del clock y se encarga de decidir cual es el siguiente proceso a
ser ejecutado. Para simplificar la lógica de la misma decidí implementar la
lista de procesos listos como una circular, eligiendo efectivamente el método
round-robin para el scheduler. Esta función luego se fija si hay procesos
listos, y en caso de haberlos los ejecuta uno por uno. En caso contrario vuelve
al estado idle. Todo es logrado con sys/queue.h.

Por último las funciones block/unblock\_process() fueron creadas para bloquear
procesos en espera de dispositivos. Como ya fue explicado no se hace uso de
discos ni ningun tipo de dispositivo que requiera bloquear procesos, por lo que
en un principio no fueron necesarios. Sin embargo al progamar el manejo de
teclado y pantalla me di cuenta que al realizar un "read()" al stdin, era
necesario  justamente bloquear al proceso y esperar una respuesta del teclado,
por lo que estas funciones entraron en juego. Simplemente sacan de la lista
ready a un proceso y lo mandan a wait, y cuando el dispositivo que lo bloqueo
avise que volvió, vuelven a agregar el proceso en ready. Más sobre este
comportamiento en la sección Teclado y Pantalla.

\subsection{MMU}

\subsection{Teclado y Pantalla, o el driver tty}

\subsection{Resultado}
